use std::collections::HashMap;
use std::path::Path;
use varj;

/// cargo run --example template_js
pub fn main() {
    // String template of the JS test worker.
    let template_path = Path::new("examples/js_worker_template.js");
    let js_worker_template: String = std::fs::read_to_string(template_path).unwrap();

    // Hash map containing values for all keys {{ key }}
    // present in the previous template.
    let replacements: HashMap<String, String> = vec![
        ("content".to_string(), content()),
        (
            "pipeFilename".to_string(),
            "/path/to/named/pipe".to_string(),
        ),
    ]
    .into_iter()
    .collect();

    println!(
        "{}",
        // Use the varj to replace all {{ key }} in template `js_worker_template`
        // by the corresponding value provided in the hash map `replacements`.
        // Return an error if there are missing keys.
        varj::parse(&js_worker_template, &replacements).unwrap()
    );
}

/// Simulate the JS content of the compiled main elm provided by some other code
fn content() -> String {
    r#"
var some = "elm_main_content";
var this_should = "be generated by the `elm make` call";
"#
    .to_string()
}
